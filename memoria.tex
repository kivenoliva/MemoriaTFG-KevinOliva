%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{subfig}

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
LINELENGTH: \\
HERRAMIENTA Y ANÁLISIS DE CUMPLIMIENTO DE LA GUÍA DE ESTILO DE PYTHON EN RELACIÓN CON LA LONGITUD MÁXIMA DE LÍNEA

\vspace{0.4cm}

\large
Curso Académico 2017/2018

\vspace{0.8cm}

Trabajo Fin de Grado


\vspace{4cm}

\large
Autor : Kevin Oliva Muñoz \\
Tutor : Dr. Gregorio Robles
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
LINELENGTH: Herramienta y Análisis de Cumplimiento de la Guía de Estilo de Python en Relación con la Longitud Máxima de Línea


\vspace{1cm}
\large
\textbf{Autor :} Kevin Oliva Muñoz \\
\textbf{Tutor :} Dr. Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Trabajo Fin de Grado se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2017, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2017
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia / mi abuelo / mi abuela}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja,
no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo 
parezca disfrutará tanto de tus logros como tú\ldots Además, la pareja quizás
no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Los lenguajes de programación suelen tener una guía de estilo que indica, entre otras cuestiones, cómo ha de formatearse el código. Este proyecto pretende realizar un estudio sobre el uso de una de las reglas que contiene la guía de estilo de Python PEP8\footnote{\url{https://www.python.org/dev/peps/pep-0008/}}.
La regla en cuestión es la siguiente: ``\textbf{Máxima longitud de las líneas:} Limita todas las líneas a un máximo de 79 caracteres''.
Esta regla ha producido un pequeño debate en la comunidad Python, ya que --según muchos desarrolladores-- seguirla al pie de la letra muchas veces tiene como resultado un peor código. Esto es debido a que, por ejemplo, hay desarrolladores que acortan el nombre de las variables hasta hacerlas ininteligibles. Si esto ocurre nos encontramos ante un problema, ya que la regla de estilo de máxima longitud está produciendo un efecto contrario al que pretendía.

En el estudio realizado en este Trabajo Fin de Grado intentamos detectar las líneas de código que han sufrido esta mala práctica por parte de los desarrolladores. Para ello, intentamos identificar --a partir de un análisis de repositorios de versiones con código de Python-- cuándo se ha cambiado el nombre de alguna variable, acortándolo para cuadrar la longitud de la línea a 79 caracteres. Los resultados obtenidos muestran que el número de ocurrencias en los que se cambia el nombre de una variable para cumplir la regla de longitud máxima de línea es muy bajo. Un análisis manual posterior, además de ofrecer una mayor perspectiva, indica que la incidencia de esta regla --a partir de los datos a los que hemos podido acceder-- en la calidad del código es realmente muy pequeña.

Para realizar este estudio se ha implementado el lado del servidor con Node.js (utilizando Express) y el lenguaje JavaScript.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado


Programming languages usually have a style guide that indicates, among other things, how to format the code. This project aims to conduct a study on the use of one of the rules contained in the Python style guide named PEP8\footnote{\url{https://www.python.org/dev/peps/pep-0008/}}.

The rule in question is as follows: ``\textbf{Maximum line length:} Limit all lines to a maximum of 79 characters''.
This rule has produced a small debate in the Python community, since --according to many developers-- following it often results in worse code. This is because, for example, there are developers who shorten the name of variables to make them unintelligible. If this occurs we face a problem, since the rule of maximum length style is producing an effect contrary to what it intended.

In the study carried out in this Undergraduate Thesis we try to detect the lines of code that have suffered this malpractice. To do this, we try to identify -from an analysis of version repositories with Python code-- if a developer has changed the name of a variable, shortening it to meet that the maximum length of the line is 79 characters or less. The results obtained show that the number of occurrences in which a variable name is changed to meet the maximum line length rule is very low. A later manual analysis, besides providing a greater perspective, indicates that the incidence of this rule --from the data that we have been able to access-- in the quality of the code is very small.

To perform this study, the server side has been implemented with Node.js (using Express) and the JavaScript language.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

\section{Motivación}
\label{sec:motivacion}

Cuando terminas de estudiar y por fin empiezas a dedicarte  profesionalmente al desarrollo de software, rápidamente te das cuenta de una cosa, 
que nunca, o casi nunca, habías pensado en tu vida de estudiante: en tu trabajo pasas más tiempo leyendo código de otra(s) persona(s) que tu 
propio código. Esto hace que, repentinamente, empiecen a cobrar sentido las frases que tanto te repetían tus profesores sobre estructurar bien tu código o elegir nombres ``inteligentes'' para las variables o funciones.

Coincidiendo con el inicio de mi etapa profesional, cuando verdaderamente me he dado cuenta de la importancia de escribir código de calidad, y no sólo ``algo que funcione'', mi tutor, Gregorio me habló de un vídeo con una charla en una \emph{PyCon}, el congreso anual más grande sobre el lenguaje Python, en el que Raymond Hettinger, uno de los desarrolladores principales de Python, expone buenas prácticas para escribir un código legible y de calidad\footnote{\url{https://www.youtube.com/watch?v=wf-BqAjZb8M}}. En el vídeo se indica que se ha de seguir unas normas de estilo (que vienen recogidas en la guía de estilo de Python, conocida como PEP8\footnote{PEP es el acrónimo de Python Enhancement Proposal, un documento que se propone y debate en la comunidad Python antes de ser definitivamente aceptado como ``oficial'', que es cuando se le asigna finalmente un número.}, ya que eso facilita la tarea de comprensión del código. Sin embargo, en el vídeo se plantea lo que para mí es una interesante cuestión: ¿Podemos dejar un código peor de lo que estaba al realizar un cambio para cumplir con una regla de la guía de estilo de Python?

Dicha cuestión es la que vamos a estudiar en este TFG. Nos centraremos en un caso muy concreto, a la vez que muy debatido en la comunidad de Python. La regla en cuestión es la siguiente:

``Máxima longitud de las líneas: Limita todas las líneas a un máximo de 79 caracteres'' 

El caso que nos preocupa es el siguiente: un desarrollador se encuentra ante una línea de código mayor a los 79 caracteres, por lo que decide cambiarla, acortando para ello el nombre de alguna variable. Al hacerlo, el nombre de la variable carece de sentido, por lo que la legibilidad del código se resiente.

Para intentar ilustrar esta cuestión, vamos a poner un pequeño ejemplo.
Imaginemos que el desarrollador ha escrito la siguiente línea de código:


\begin{verbatim}
'subtitles': self.extract-subtitles(video_id, video_subtitles_id)
\end{verbatim}

Si nos encontramos analizando código y leemos esta línea, en principio, se entiende bastante bien, sin necesidad de contar con más contexto. Podemos suponer fácilmente que lo que estamos obteniendo en la variable ``subtitles'' son los subtítulos de un vídeo, los cuales extraemos llamando a la función ``extract-subtitles'' pasándole como parámetros el id del vídeo y el id de los subtitulos. 

Con el contexto que nos daría el resto de código de este fichero, es posible que no haga falta ir a la documentación de la función ``extract-subtitles'', porque sabemos todo lo que nos hace falta con esta línea y podremos seguir leyendo el código que estamos analizando sin perder más tiempo.

Esta línea en sí, no ocupa más que 69 caracteres. Pero, supongamos que por motivos de \emph{indentación}\footnote{Este término \emph{indentación} significa mover un bloque de texto hacia la derecha insertando espacios o tabuladores, para así separarlo del margen izquierdo y mejor distinguirlo del texto adyacente. Es utilizado para mejorar la legibilidad del código fuente por parte de los programadores.}, esta línea superara los 79 caracteres. El desarrollador ha intentado refactorizar su código pero no consigue quitar las \emph{indentaciones} y como le ha saltado el \emph{warning} de que no cumple la regla de estilo únicamente por la longitud de la línea, decide para no perder más tiempo, acortar el nombre de las variables, y forzando un caso extremo, también el de la función, de tal forma que la línea quedara con menos de 80 caracteres y cumplir con la regla. De forma que la línea resultante podría quedar de la siguiente forma:

\begin{verbatim}
'subtitles': self.e_s(v_id, v_s_id) 
\end{verbatim}

Como se puede ver, la línea ahora es más difícil de explicar de por sí. Si estamos analizando código bien puede pasar que seríamos incapaces de saber cómo estamos obteniendo la variable ``subtitles'', necesitaríamos irnos a la función para intentar entender qué hace, y qué parámetros le están llegando. La línea ahora cumple las reglas de estilo, pero es ilegible. Hemos ido a peor.

Este hecho me parece digno de estudio, por varios motivos. Uno de ellos, indudablemente, está relacionado con el debate que puede crear en la comunidad Python, sobre si un código que cumple la guía de estilo PEP8 puede ser de peor calidad que uno que no lo cumpla.

Pero siendo sincero, el motivo por el cual decidí realizar el proyecto sobre este tema fue que, con mi experiencia como estudiante, no pude evitar imaginar el siguiente pensamiento por parte de cualquiera de nosotros: ``He terminado mi práctica de Python, voy a pasar a mi código un filtro que me he descargado de la guía de estilo PEP8 para entregar un buen código, lo más importante es que pase este filtro. Por tanto, si me salta algún error haré cualquier cambio rápido y sin pensar mucho sólo para forzar a que el filtro pase correctamente.''

Creo firmemente que, como estudiantes, no somos capaces de asimilar la importancia de escribir un código de calidad, y de las horas y horas que ahorraremos a nuestros compañeros de trabajo, o a nosotros mismo cuando retomamos código propio de hace tiempo. Son cosas simples, pero es importante que desde el principio de nuestra formación se adopten estas buenas costumbres.

\section{La Guía de Estilo PEP8}
\label{sec:la-guia-de-estilo-PEP8}

Desde que empezamos a escribir código y conforme progresamos, adquirimos ciertas pautas que definen la manera en que expresamos nuestras ideas en el lenguaje que manejemos, ya sea JavaScript, Python, C u otro. Esto define nuestro estilo, y tiene en cuenta la manera en la que \emph{indentamos}, definimos nombres de variables y funciones, o el proceso de realizar o no comentarios de código, entre otros.

¿Por qué es tan importante seguir un estilo cuando estamos programando?
El principal y más importante motivo es porque el código debe ser mantenido, ya sea por nosotros mismos o por otras personas. Y a lo largo de nuestra vida como desarrolladores, pasamos muchas más horas leyendo código que escribiéndolo.
\ \\ % asi se hacen 1 saltos de linea

Para esto nacieron las guías de estilo de código. El principal objetivo de una guía de estilo es que nuestro código sea más fácil de leer, compartir y analizar. Facilita la consistencia entre el código fuente de distintos usuarios y hace que nuestro código sea mucho más mantenible.

Las guías de estilo son algo que está generalizado en los distintos lenguajes de programación, por ejemplo para PHP tenemos  PSR-2\footnote{http://www.php-fig.org/psr/psr-2/}, y en JavaScript una de las más notables es Crockford\footnote{http://javascript.crockford.com/code.html}. No hay una sola guía de estilo para cada lenguaje, podemos encontrar varias de distintas fuentes (es muy común que los proyectos de software libre tengan una propia). Algo muy común es consultar las guías que ha creado Google. Por ejemplo, para Java podemos encontrar la siguiente\footnote{https://google.github.io/styleguide/javaguide.html}.
\ \\ % asi se hacen 1 saltos de linea

Esta memoria se centra en la guía de estilo para Python PEP8. La guía de estilo PEP8 fue realizada por Guido van Rossum, Barry Warsaw y Nick Coghlan. Está dedicada a la recopilación de los estándares seguidos por los desarrolladores de Python a la hora de escribir código Python para la librería estándar. Esta guía está conformada por varias convenciones, en las cuales no entraremos en profundidad, destacaremos una de ellas, alrededor de la que se centra este proyecto:``Limitar los tamaños de línea a 79 caracteres como máximo''.

Para aplicar las reglas de calidad que marca PEP8, tenemos a nuestra disposición varias herramientas automáticas para pasarle a nuestro código. En el capítulo~\ref{chap:estado-del-arte} se habla más en profundidad sobre una de ellas, esta herramienta es \texttt{pycodestyle}, antes conocida como \texttt{pep8}.



\section{Estructura de la memoria}
\label{sec:estructura-de-la-memoria}
En este apartado del capítulo se explica muy brevemente la estructura de la memoria, dando a conocer los objetivos de cada capítulo para facilitar así la lectura de la misma:  
\ \\ \ \\ 
\begin{enumerate}
	\item \textbf{Introducción: }En este capítulo se explica el contexto de este proyecto, así como las razones por las que se elige el tema a tratar.
	\item \textbf{Objetivos: }En este capítulo se detalla cada uno de los objetivos que se han planteado desde el inicio del proyecto.
	\item \textbf{Estado del arte: }Aquí presentamos las tecnologías con las que se ha implementado el proyecto, además de algún concepto para entender mejor la estructura del mismo.
	\item \textbf{Diseño e implementación: }Este capítulo profundiza e intenta explicar en detalle el desarrollo del proyecto.
	\item \textbf{Resultados: }Aquí se presenta, a modo de resumen, como ha quedado finalmente el proyecto.
	\item \textbf{Conclusiones: }Es el capítulo final; en él se intenta evaluar de forma general el proyecto, haciendo hincapié en los conceptos aprendidos en su elaboración.
\end{enumerate}

Finalmente se expondrá la bibliografía, que se ha consultado para la elaboración del trabajo y de la memoria.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Objetivos}
\label{chap:objetivos}

\section{Objetivo principal}
\label{sec:objetivo-principal}

Este proyecto tiene como objetivo principal:

\vspace{0.2cm}
\begin{center}
\fbox{\parbox{0.85\textwidth}{``Analizar una serie de repositorios reales de GitHub con bastante código Python, para obtener unos resultados y en función de ellos, decidir si el hábito explicado en el apartado anterior es un problema real en los desarrolladores de Python''.}}
\end{center}
\vspace{0.2cm}

El proyecto consistirá en un programa software que analizará código fuente de un programa en el lenguaje de programación Python y detectará aquellas líneas que han sido acortadas cambiando el nombre de una variable por un nombre más corto, y por tanto, menos entendible, para conseguir pasar la regla de la guía de estilo PEP8 de la máxima longitud de línea.


Por una parte, se pretende hacer un estudio bastante amplio, con un volumen de repositorios de GitHub grande, para obtener unos resultados lo suficientemente amplios como para poder llegar a una conclusión. Se busca detectar si este mal hábito se encuentra extendido entre los desarrolladores de Python.


También se pretende alcanzar otro objetivo más a largo alcance, el cual consiste en intentar interiorizar una cuestión, sobre todo a nivel de estudiantes. Dicha cuestión es la importancia de saber realmente lo que es un buen código, sobre todo, no caer en el típico error cuando eres estudiante de pensar que un buen código es algo que funciona.

Según está orientado en la actualidad el aprendizaje de la programación a nivel de universidad, es muy difícil darse cuenta que el código que produces no es algo que vas a escribir una vez, vas a probar que funciona, vas a entregar y no vas a volver a ver en tu vida. Este ciclo es lo que suele pasar con el código que creas como estudiante. Esto unido a ciertas circunstancias, como agobios y prisas por los plazos de entrega, o que en algunas ocasiones sólo se valore el resultado del programa, hace que generalmente se creen malos hábitos por parte de los alumnos a la hora de programar.


Este proyecto de fin de grado intenta llegar a este objetivo creando un ``debate'' alrededor del caso concreto que se estudia. ¿Es mejor el código que no cumple la guía de estilo PEP8 antes de realizar el cambio, pero que tiene un buen nombre de variable?, ¿o es mejor el código después del cambio que cumple la guía de estilo PEP8 pero que ha dejado la variable con un nombre sin sentido?

Quizás la respuesta correcta sea decir que se debe cambiar la línea de código para que cumpla la regla de máxima longitud de línea pero realizando otro cambio, y si no es posible cambiar esa línea, darle una vuelta al código para \emph{refactorizarlo} y hacer que todas las líneas cumplan de esta forma las reglas de calidad.


Lo que se intenta decir con esto es que cuando un estudiante ya ha adquirido ciertos conocimientos técnicos sobre la programación y sobre la generación de código de calidad, debe darse cuenta que tenemos en nuestra mano una serie de reglas de calidad como la guía de estilo PEP8 o similares, las cuales se deben utilizar, pero no de cualquier forma. Es decir, hay que pararse a pensar un minuto y ser coherente e inteligente a la hora de aplicarlas en nuestro desarrollo, y no dejar un código peor que el que teníamos antes por intentar forzar a que pasen estas reglas de cualquier manera.


\section{Objetivos secundarios}
\label{sec:objetivos-secundarios}
Aparte del objetivo explicado anteriormente, a la hora de realizar este proyecto, se han tenido en cuenta los siguientes objetivos secundarios:
\begin{itemize}
	\item \textbf{Trabajar de una forma orientada al mundo profesional:} Se ha intentado llevar una metodología de trabajo lo más parecida posible a lo que nos encontraremos en un futuro entorno profesional. Para ello se ha intentado mantener un uso constante de \texttt{git} y GitFlow.
\end{itemize}

\begin{itemize}
	\item \textbf{Aplicar tecnologías e ideas no vistas durante la vida universitaria: } El proyecto de fin de carrera es el broche, la guinda a nuestra vida universitaria. Debido a esto, he intentado basar este proyecto sobre tecnologías e ideas de trabajo que no conozco en profundidad, ya que o no se han enseñado, o se ha pasado por ellas de ``refilón'' en mi vida universitaria. De esta forma lo que busco es ampliar mis conocimientos y aprovechar esto para conocer nuevas herramientas que me pueden valer para mi futura vida laboral. Esta cuestión puede dividirse, sobre todo, en dos casos:
	\begin{enumerate}
		\item En cuanto a la aplicación de tecnologías, he usado un servidor JavaScript, Node.js con Express. Mi elección se debe a que en la universidad se ha enseñado a montar servidores en lenguajes como Java, y sobre todo, con Python y Django.
		Para la base de datos he utilizado MongoDB, en lugar de SQL por el mismo motivo. En la universidad hemos utilizado bases de datos relacionales, y quería utilizar una no relacional, para entender mejor los \emph{pros} y \emph{contras} de cada una de ellas, y tener más conocimientos sobre cuál elegir en mis futuros desarrollos. 
		\item Enfocar una idea de trabajo más orientada a la investigación. Normalmente en nuestra vida como estudiante partimos siempre de un enunciado redactado al empezar a desarrollar. En el proyecto tenemos la oportunidad de investigar sobre una idea para realizar luego nuestro desarrollo.
	\end{enumerate}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:estado-del-arte}

En esta sección vamos a describir brevemente las tecnologías aplicadas en o relacionadas con este proyecto.

\section{App Cliente-Servidor} 
\label{sec:app-cliente-servidor}

La arquitectura \emph{cliente-servidor} es una de las más extendidas en la actualidad. Dicha estructura es un modelo de aplicación distribuida en el que las tareas se reparten entre los proveedores de recursos o servicios, llamados \textbf{servidores}, y los demandantes, llamados \textbf{clientes} (véase figura~\ref{fig:cliente-servidor}). Un cliente realiza peticiones a otro programa, y es el servidor quien atiende su petición y le da respuesta: 

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.66]{img/esquemaClienteServidor}
	\caption{Esquema básico de la estructura cliente-servidor}
	\label{fig:cliente-servidor}
\end{figure}

Esta arquitectura presenta una clara separación de las responsabilidades, lo que facilita y clarifica el diseño del sistema. Es una arquitectura claramente centralizada, ya que toda la información reside en el servidor, y el cliente es el que realiza peticiones para obtener dicha información. Esto provoca que el servidor posea una lógica más compleja, y que potencialmente sea capaz de manejar de forma distinta las peticiones dependiendo de quién las realice.

En nuestro proyecto no hemos realizado como tal una \emph{app} de cliente-servidor, ya que ha ido más enfocado a la investigación y a la obtención de un resultado. Sin embargo, el código realizado para obtener dichos resultados se ha dejado organizado en la parte del servidor de una aplicación web, para obtenerlo con distintas peticiones. Si en un futuro se quiere mejorar este proyecto, y se decide hacer una aplicación web con el contenido investigado aquí, solo sería necesario realizar la parte del cliente.

\section{Python} 
\label{sec:python}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.3]{img/python-logo}
	\caption{Python}
	\label{fig:python}
\end{figure}


Python es un lenguaje de programación de muy alto nivel, multiplataforma y multiparadigma, el cual, fue creado a finales de los años 80 por el holandés  Guido van Rossum, Python fue creado como sucesor del lenguaje de programación ABC. El logo de Python se puede ver en la figura~\ref{fig:python}.\\
¿Qué quiere decir que es un lenguaje multiplataforma? Quiere decir que es un lenguaje interpretado, y por tanto no necesita compilación. Esto tiene como ventaja, por ejemplo, que da igual el sistema operativo donde se ejecute, o que aporta mayor rapidez al desarrollarlo.

¿Qué quiere decir que es multiparadigma? Esto quiere decir que no obliga al desarrollador a adaptarse a un estilo de programación concreto, Python soporta programación funcional, programación imperativa y programación orientada a objetos.\\
Python se caracteriza por tener una sintaxis limpia y ordenada, haciendo mucho hincapié en la legibilidad del código, a pesar de ello, tiene funcionalidades muy avanzadas, propias de lenguajes como C o C++.\\
Python es un lenguaje que ha adquirido gran popularidad en los últimos años, algunas de las razones por las que esto ha sucedido son las siguientes:

\begin{itemize}
	\item Sencillez y velocidad a la hora de crear desarrollos completos, normalmente un programa en Python tendrá muchas menos líneas que sus equivalente en otros lenguajes (java, C, etc).
	\item Ofrece una gran cantidad de librerías, con funciones incorporadas, funcionalidades o tipos de datos, que favorecen la realización de muchas tareas sin necesidad de empezar completamente de cero.
	\item Se puede obtener de forma gratuita y utilizarse con fines comerciales.
\end{itemize}


\section{\texttt{pycodestyle} (antes \texttt{pep8})} 
\label{sec:pycodestyle}

Como ya hemos dicho anteriormente cuando hablábamos de PEP8, existen herramientas con las que podemos comprobar de forma automática si nuestro código cumple las reglas que dicta el PEP8. Aquí vamos a hablar un poco más en profundidad de una de ellas: ``\texttt{pycodestyle}'', antes conocida como ``PEP8''. Se cambió de nombre para evitar confusiones con la propia guía de estilo.

Este herramienta nos permite pasar un análisis una vez nuestro código está terminado, para ver si cumple calidad. Podemos encontrar información sobre esta herramienta en GitHub\footnote{\url{https://github.com/PyCQA/pycodestyle}}. Básicamente, la forma de utilizarla y lo que nos aporta es lo siguiente:

Podemos instalar, actualizar o desinstalar la herramienta de forma fácil con los siguientes comandos:

\begin{verbatim}
$ pip install pycodestyle
$ pip install --upgrade pycodestyle
$ pip uninstall pycodestyle
\end{verbatim}

Una vez instalado podemos revisar nuestro código de forma sencilla, por ejemplo, con el siguiente comando, analizamos el código fuente del fichero ``optparse.py'':
\begin{verbatim}
$ pycodestyle --first optparse.py
\end{verbatim}

La salida que \texttt{pycodestyle} nos proporciona sería la siguiente:
\begin{verbatim}
optparse.py:69:11: E401 multiple imports on one line
optparse.py:77:1: E302 expected 2 blank lines, found 1
optparse.py:88:5: E301 expected 1 blank line, found 0
optparse.py:222:34: W602 deprecated form of raising exception
optparse.py:347:31: E211 whitespace before &#39;(&#39;
optparse.py:357:17: E201 whitespace after &#39;{&#39;
optparse.py:425:80: E501 line too long (82 characters)
optparse.py:472:29: E221 multiple spaces before operator
optparse.py:544:21: W601 .has_key() is deprecated, use &#39;in&#39;
\end{verbatim}

Como vemos, \texttt{pycodestyle} nos muestra de manera clara la línea y el sitio justo donde estamos cometiendo el error de calidad y por el cual no cumplimos la norma correspondiente de la guía PEP8.

Podemos ver por ejemplo como en la siguiente línea:
\begin{verbatim}
optparse.py:425:80: E501 line too long (82 characters)
\end{verbatim}

se nos muestra el mensaje del error que un programador verá cuando una línea supera el máximo tamaño de línea permitido. Esta herramienta detecta el error, pero es el desarrollador el que debe tomar tomar le decisión de cómo
solucionarlo.

\section{Otros programas del estilo de \texttt{pycodestyle}} 
\label{sec:otros-programas-del-estilo-de-pycodestyle}

A parte del actual \texttt{pycodestyle}, existen otras herramientas parecidas que también nos sirven para analizar la calidad de nuestro código Python. Entre ellas cabe destacar \texttt{pylint} y \texttt{pyflakes}.

\begin{itemize}
	\item \textbf{ \texttt{pyflakes}: } Es un programa sencillo que comprueba los errores de los archivos fuente de Python. Funciona analizando el archivo de origen, no importándolo, por lo que es seguro utilizar en módulos con efectos secundarios. También es mucho más rápido.
\end{itemize}

\begin{itemize}
	\item \textbf{ \texttt{pylint}: } Es otro comprobador de código fuente para Python. Sigue el estilo recomendado por PEP 8. Es similar a \texttt{pychecker} y \texttt{pyflakes}, pero incluye las siguientes características: comprobación de la longitud de cada línea, comprobar si los nombres de las variables están bien formados de acuerdo con la norma de codificación del proyecto, comprobación de si las interfaces declaradas se implementan realmente.
\end{itemize}


\section{JavaScript} 
\label{sec:JavaScript}


\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{img/javascript}
	\caption{JavaScript}
	\label{fig:javascript}
\end{figure}

JavaScript es un lenguaje orientado a objetos y basado en prototipos. Una de sus características más importantes es que se define como un lenguaje asíncrono, por lo que es muy útil para reaccionar a eventos por parte del usuario. Es un lenguaje interpretado, por lo que no es necesario compilar los programas para ejecutarlos. En otras palabras, los programas escritos con JavaScript se pueden probar directamente en cualquier navegador sin necesidad de procesos intermedios. En la figura~\ref{fig:javascript} se puede ver el logo de JavaScript.

Se utiliza principalmente en su forma del lado del cliente (\emph{client-side}), implementado como parte de un navegador web permitiendo mejoras en la interfaz de usuario y páginas web dinámicas, una página web dinámica es aquella que incorpora efectos como texto que aparece y desaparece, animaciones, acciones que se activan al pulsar botones y ventanas con mensajes de aviso al usuario.

Sin embargo, existe una forma de JavaScript del lado del servidor(\emph{Server-side JavaScript} o SSJS), como veremos más adelante en esta memoria cuando profundicemos en Node.js.



\section{Node JS} 
\label{sec:node-js}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{img/nodejs}
	\caption{Node.js}
	\label{fig:node}
\end{figure}


Node.js~\cite{Node.js, martinez2015node} es una librería y entorno de ejecución de E/S dirigida por eventos y por lo tanto, asíncrona que se ejecuta sobre el intérprete de JavaScript creado por Google V8. El logo de Node.js se muestra en la figura~\ref{fig:node}.

Node.js ejecuta JavaScript utilizando el motor V8, desarrollado por Google. Este motor permite a Node.js proporcionar un entorno de ejecución del lado del servidor que compila y ejecuta JavaScript a velocidades increíbles. El aumento de velocidad es importante debido a que V8 compila JavaScript en código de máquina nativo, en lugar de interpretarlo o ejecutarlo como \emph{bytecode}. Node es de código abierto, y se ejecuta en Mac OS X, Windows y Linux.

Aunque JavaScript tradicionalmente ha sido relegado a realizar tareas menores en el navegador, es actualmente un lenguaje de programación total, tan capaz como cualquier otro lenguaje tradicional como C++, Ruby o Java. Además JavaScript tiene la ventaja de poseer un excelente modelo de eventos, ideal para la programación asíncrona.

%¿Cuál es la razón por la que decidimos adentrarnos en elaborar un servidor en JavaScript con Node.js?

¿Cuál es el problema con los programas de servidor actuales? A medida que crece su base de clientes, si quieres que tu aplicación soporte más usuarios, necesitarás agregar más y más servidores. Esto hace que el cuello de botella en toda la arquitectura de aplicación Web era el número máximo de conexiones concurrentes que podía manejar un servidor. Node.js resuelve este problema cambiando la forma en que se realiza una conexión con el servidor. En lugar de generar un nuevo hilo de OS para cada conexión (y de asignarle la memoria acompañante), cada conexión dispara una ejecución de evento dentro del proceso del motor de Node.js. Node.js también afirma que nunca se quedará en punto muerto, porque no se permiten bloqueos.




\section{Express} 
\label{sec:express}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.88]{img/express}
	\caption{Express.js}
	\label{fig:express}
\end{figure}

Express~\cite{Express} es sin duda el framework más conocido de Node.js, es una extensión del poderoso connect\footnote{\url{https://github.com/senchalabs/connect#readme}} y esta inspirado en sinatra\footnote{\url{http://www.sinatrarb.com/documentation.html}}, además es robusto, rápido, flexible, simple, etc. Proporciona una delgada capa de características de aplicación web básicas, que no ocultan las características de Node.js que tanto ama y conoce.

El verdadero éxito de Express se encuentra en lo sencillo que es de usar. Tienes la capacidad de crear de forma rápida y sencilla una API sólida. Además, Express abarca un sin número de aspectos que muchos desconocen pero son necesarios. El logo de Express se puede ver en la figura~\ref{fig:express}.

De entre las tantas cosas que tiene este framework podemos destacar:

\begin{itemize}
	\item Session Handler.
	\item 11 \emph{middleware} poderosos así como de terceros.
	\item cookieParser, bodyParser \ldots
	\item vhost
	\item router
\end{itemize}



\section{MongoDB} 
\label{sec:mongodb}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{img/mongoDB}
	\caption{MongoDB}
	\label{fig:mongodb}
\end{figure}

MongoDB~\cite{MongoDB} forma parte de la nueva familia de sistemas de base de datos NoSQL, es la base de datos NoSQL líder y permite a las empresas ser más ágiles y escalables. El logo de MongoDB se muestra en la figura~\ref{fig:mongodb}.

En lugar de guardar los datos en tablas como se hace en las base de datos relacionales, MongoDB guarda estructuras de datos en documentos similares a JSON con un esquema dinámico (MongoDB utiliza una especificación llamada BSON). Esto hace que sea una base de datos ágil ya que permite a los esquemas cambiar rápidamente cuando las aplicaciones evolucionan, proporcionando siempre la funcionalidad que los desarrolladores esperan de las bases de datos tradicionales, tales como índices secundarios, un lenguaje completo de búsquedas y consistencia estricta.


La arquitectura completa de las tecnologías utilizadas en este proyecto se puede ver en la figura~\ref{fig:todo}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{img/appNodeMongoAngular}
	\caption{Estructura de aplicación MEAN: Mongo + Express + Angular + Node}
	\label{fig:todo}
\end{figure}


\section{JSON} 
\label{sec:json}

 JSON (JavaScript Object Notation)~\cite{JSON} es un formato de texto ligero para el intercambio de datos. JSON es un subconjunto de la notación literal de objetos de JavaScript aunque hoy, debido a su amplia adopción como alternativa a XML, se considera un formato de lenguaje independiente. JSON nació como una alternativa a XML, el fácil uso en JavaScript ha generado un gran número de seguidores de esta alternativa. Se puede ver un ejemplo de una estructura de datos en JSON en la figura~\ref{fig:json}.
 
 Una de las supuestas ventajas de JSON sobre XML como formato de intercambio de datos es que es mucho más sencillo escribir un analizador sintáctico (parser) de JSON, que ha sido fundamental para que JSON haya sido aceptado por parte de la comunidad de desarrolladores AJAX, debido a la ubicuidad de JavaScript en casi cualquier navegador web.
 
 Otra ventaja a tener en cuenta del uso de JSON es que puede ser leído por cualquier lenguaje de programación. Por lo tanto, puede ser usado para el intercambio de información entre distintas tecnologías.


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.635]{img/jsonEjemplo}
	\caption{Ejemplo del formato JSON}
	\label{fig:json}
\end{figure}

\section{Git} 
\label{sec:git}


Los sistemas de control de versiones (VCS) son programas que tienen como objetivo controlar los cambios en el desarrollo de cualquier tipo de software, permitiendo conocer el estado actual de un proyecto, los cambios que se le han realizado a cualquiera de sus piezas, las personas que intervinieron en ellos, etc.

\texttt{git}~\cite{Git} es un software de control de versiones diseñado por Linus Torvalds, pensando en la eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de archivos de código fuente.
La principal diferencia entre \texttt{git} y cualquier otro VCS es cómo \texttt{git} modela sus datos. Conceptualmente, la mayoría de los demás sistemas almacenan la información como una lista de cambios en los archivos. Estos sistemas (CVS, Subversion, Perforce, Bazaar, etc.) modelan la información que almacenan como un conjunto de archivos y las modificaciones hechas sobre cada uno de ellos a lo largo del tiempo, como se puede ver en la figura~\ref{fig:git}.

\begin{figure}
	\centering
	\includegraphics[scale=0.6]{img/git1}
	\caption{Esquema de como organizan la información los demás VCS}
	\label{fig:git}
\end{figure}

Como se puede ver en la figura~\ref{fig:git2}, \texttt{git} no modela ni almacena sus datos de este modo. En cambio, \texttt{git} modela sus datos más como un conjunto de instantáneas de un mini sistema de archivos. Cada vez que confirmas un cambio, o guardas el estado de tu proyecto en Git, él básicamente hace una foto del aspecto de todos tus archivos en ese momento, y guarda una referencia a esa instantánea. Para ser eficiente, si los archivos no se han modificado, \texttt{git} no almacena el archivo de nuevo, sólo un enlace al archivo anterior idéntico que ya tiene almacenado.\\


\begin{figure}
	\centering
	\includegraphics[scale=0.6]{img/git2}
	\caption{Esquema de como \texttt{git} organiza la información}
	\label{fig:git2}
\end{figure}


\section{GitFlow} 
\label{sec:gitflow}

GitFlow~\cite{Gitflow} es un modelo de flujo de trabajo para \texttt{git} que da muchísima importancia a las ramas y que de hecho las crea de varios tipos, de forma temática, tal que cada tipo de rama es creada con un objetivo en concreto, como se puede ver en la figura~\ref{fig:gitflow}:

\begin{enumerate}
	\item \textbf{Master: }La rama \emph{master} es la única rama existente que nos proporciona \texttt{git} al crear un repositorio nuevo. Esta rama  tiene como objetivo ser el contenido del servidor de producción. Es decir, el HEAD de esta rama ha de apuntar en todo momento a la última versión de nuestro proyecto.
	

No se va a desarrollar desde esta rama en ningún momento.
	
	\item \textbf{Develop: }Esta rama funciona paralelamente a la master. Si la anterior contenía las versiones desplegadas en producción, esta (que también estará sincronizada con origin/develop) contendrá el último estado de nuestro proyecto. Es decir, esta rama contiene todo el desarrollo del proyecto hasta el último \texttt{commit} realizado.
	

Cuando esta rama adquiera estabilidad y los desarrolladores quieran lanzar una nueva versión, bastará con hacer un \emph{merge} a la rama \emph{master}. Esto será lo que cree una nueva versión de nuestro proyecto.
	
	\item \textbf{Features: }Que varias personas trabajen sobre la misma rama es bastante caótico ya que se aumenta el número de conflictos que se dan. A pesar de que los repositorios distribuidos faciliten esta tarea al guardar los \texttt{commits} solo localmente, tiene mucho más sentido usar la potencia de las ramas de \texttt{git}.
	

Cada vez que necesitemos programar una nueva característica en nuestro proyecto crearemos una nueva rama para la tarea.
	

Ya que \emph{develop} contiene la última foto de nuestro proyecto, crearemos la nueva rama a partir de aquí. Una vez finalizada la tarea, solo tendremos que integrar la rama creada dentro de \emph{develop}. Una vez integrada la rama en \emph{develop}, podremos eliminarla y actualizar \emph{origin}.	
	
 
	
\item \textbf{Release: }Cuando hemos decidido que el código desarrollado hasta ahora pertenece a una versión de nuestro proyecto, y tenemos actualizado la rama \emph{develop} con dicho código, crearemos una rama \emph{release}.
		
	\item \textbf{HotFix: }Cuando detectamos algún error en producción (rama \emph{master}), creamos una rama \emph{HotFix}, en la que se arregla rápidamente el error (sin hacer ningún desarrollo más). Cuando tenemos el arreglo preparado integramos esta rama con la rama \emph{master} y la \emph{develop} para que todos los desarrolladores tengan el error solventado.
\end{enumerate}



\begin{figure}
	\centering
	\includegraphics[scale=0.8]{img/gitflow}
	\caption{Diagrama GitFlow}
	\label{fig:gitflow}
\end{figure}

En el caso de este proyecto, es difícil usar todo el esquema explicado aquí de GITFLOW, debido a que es un proyecto pequeño, es decir, sin distintos entornos de desarrollo(desarrollo, preproducción, producción, etc), y no ha contado con varios desarrolladores de forma simultánea. Sin embargo, he visto muy útil la utilización de la rama \textit{feature}, para tener siempre la última versión estable guardada en \emph{develop}, y aislar el desarrollo de nuevas funcionalidades en éstas ramas. Una vez terminada y probada la nueva funcionalidad, integraba la rama \emph{feature} con la \emph{develop} y borraba la \emph{feature}. Este ha sido el uso que he dado en mi caso a \texttt{GitFlow}.
Para llevar esto a cabo, he encontrado \textit{Source Tree} (véanse la figura~\ref{fig:sourcetree1} y la figura~\ref{fig:sourcetree2}), que es una interfaz visual para utilizar Git. Es especialmente útil cuando queremos utilizar \texttt{GitFlow}, ya que es un poco lioso de entender con tantas ramas, sobre todo cuando se mantiene todo de forma manual. Con Source Tree podremos ver todo el esquema de ramas que forme nuestro proyecto de forma visual y crear las distintas ramas de forma mucho más fácil.

\ \\ \ \\ \ \\ \ \\ \ \\ \ \\ \ \\ \ \\ \ \\ \ \\ % asi se hacen 1 saltos de linea

\begin{figure}
	\centering
	\includegraphics[width=150mm]{img/sourceTree2}
	\caption{Inicialización del método \texttt{GitFlow} en un proyecto.}
	\label{fig:sourcetree1}
\end{figure}



\begin{figure}
	\centering
	\subfloat[]{
		\includegraphics[width=0.3\textwidth]{img/sourceTree1}}
	\subfloat[]{
		\includegraphics[width=0.3\textwidth]{img/sourceTree3}}
	\caption{Imágenes de ejemplo de uso de Source Tree.}
	\label{fig:sourcetree2}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{sec:diseno}

%\section{Análisis del estudio realizado} 
%\label{sec:esquema-del-funcionamiento-del-estudio}

En el diagrama de flujo de la figura~\ref{fig:diagrama} se muestra el funcionamiento de nuestro estudio sobre el problema que estamos tratando en este proyecto. En las siguientes secciones se entrará en detalle sobre cada uno de los pasos.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{img/diagramaFlujo}
	\caption{Diagrama de flujo del funcionamiento del estudio}
	\label{fig:diagrama}
\end{figure}

\section{Análisis de los repositorios} 
\label{sec:analisis-de-los-repositorios}

Para la realización de este proyecto contaremos con una batería de repositorios almacenados previamente, los cuales serán la muestra de este estudio.

En primer lugar se analizan dichos repositorios. Si se detecta un fichero python dentro del repositorio que se está analizando, se procesa línea por línea, y en función de la longitud que posean se dividen en tres grupos:

\begin{itemize}
	\item Grupo 1: ``Zona verde'', la línea posee menos de 70 caracteres de longitud.
\end{itemize}

\begin{itemize}
	\item Grupo 2: ``Zona naranja'', la línea posee entre 70 y 79 caracteres de longitud.
\end{itemize}

\begin{itemize}
	\item Grupo 3: ``Zona roja'', la línea posee 80 o más caracteres de longitud. Este grupo de líneas no cumple con las reglas de estilo PEP8.
\end{itemize}

El Grupo 2: ``Zona naranja'', es el grupo determinante para el estudio. Las líneas pertenecientes a este grupo tienen la posibilidad de haber pertenecido al Grupo 3: ``Zona roja'' en algún momento de su ``pasado'', y por tanto, tienen la posibilidad de estar, en la actualidad, en la ``Zona naranja'' debido a un cambio motivado por la modificación de una variable.

Como se ha explicado antes, las líneas procesadas se dividen en 3 grupos, en el momento en que se detecta una línea perteneciente al grupo ``Zona naranja'', se crea un nuevo objeto en la BBDD, en este caso, dentro del esquema Linea. El objeto guardado tiene el siguiente formato:

\begin{verbatim}
var lineaSchema = mongoose.Schema({

linea: String,
fichero: String,
numLinea: String,
longitudLinea: String,
pasadoRojo: Boolean
historia: []

}); 
\end{verbatim}

\ \\  % asi se hacen 1 saltos de linea
Donde cada parámetro contiene:

\begin{itemize}
	\item \textbf{línea: }Contenido de la línea.
\end{itemize}
\begin{itemize}
	\item \textbf{fichero: }Ruta del fichero dentro del repositorio git.
\end{itemize}
\begin{itemize}
	\item \textbf{numLínea: }Número de la línea dentro del fichero.
\end{itemize}
\begin{itemize}
	\item \textbf{longitudLinea: }Longitud de la línea.
\end{itemize}
\begin{itemize}
	\item \textbf{pasadoRojo: }Parámetro \emph{boolean}. Este parámetro indica si la línea en cuestión ha pertenecido en algún momento de su pasado al grupo ``Zona roja''. En la creación de este objeto en este punto del análisis siempre se setea este parámetro a \emph{False}, debido a que esta cuestión todavía no se ha comprobado. Se hará más adelante.
\end{itemize}
\begin{itemize}
	\item \textbf{historia: }Parámetro \emph{array}. Este parámetro almacena los diferentes estados que ha tenido la línea a lo largo de su historia. Al igual que ocurre con el parámetro anterior, en la creación del objeto en este punto, este array se inicializa y guarda vacío, debido también a que en este punto no se ha realizado todavía esta comprobación. Más adelante se explica como se procesa y se actualiza este parámetro.
\end{itemize}

Cuando se finaliza este primer proceso, además del objeto perteneciente al esquema Línea, que acabamos de contar, se dispone de un recuento total de las líneas analizadas, así como un resumen de toda la muestra utilizada indicando por cada repositorio, su nombre y líneas analizadas de cada tipo. De esta forma se tiene disponible, de manera organizada, toda la información de los datos analizados. De manera que resulte más fácil llegar a una conclusión en el futuro.
Para ello se crea un nuevo objeto en la BBDD, dentro del esquema Repositorios, con el siguiente formato:


\begin{verbatim}
var repositorioSchema = mongoose.Schema({

	nombreRepo: Array,
	lineasVerdes: String,
	lineasRojas: String,
	lineasNaranjas: String
	
});
\end{verbatim}

Donde cada parámetro contiene:

\begin{itemize}
	\item \textbf{nombreRepo: }Parámetro \emph{array}. Contiene una serie de objetos, los cuales poseen los parámetros: nombre del repositorio, líneas verdes analizadas en dicho repositorio, líneas naranjas analizadas en dicho repositorio, líneas rojas analizadas en dicho repositorio.
\end{itemize}
\begin{itemize}
	\item \textbf{lineasVerdes: }Número de líneas pertenecientes a este grupo encontradas en el total del análisis.
\end{itemize}
\begin{itemize}
	\item \textbf{lineasRojas: }Número de líneas pertenecientes a este grupo encontradas en el total del análisis.
\end{itemize}
\begin{itemize}
	\item \textbf{lineasNaranjas: }Número de líneas pertenecientes a este grupo encontradas en el total del análisis.
\end{itemize}

\ \\  % asi se hacen 1 saltos de linea

\section{Análisis del grupo de líneas seleccionadas para nuestro estudio} 
\label{sec:analizar-el-grupo-de-lineas-seleccionadas-para-nuestro-estudio}

Cabe destacar que en este punto ya se han descartado las líneas que consideramos comentarios, en el proceso de clasificación de las líneas en los 3 grupos mencionados. De forma que en la BBDD se cuenta únicamente con las líneas que consideramos conflictivas, es decir, las pertenecientes al Grupo 2: ``Zona naranja'', y que se deben seguir analizando.

Posteriormente, se procesan una a una todas las líneas almacenadas dentro de la BBDD y se ejecuta la instrucción \texttt{git log} para cada una de ellas, para así poder estudiar su pasado.

\section{Ejecución de \texttt{git log}} 
\label{sec:ejecucion-del-comando-git-log}

En primer lugar, vamos a abrir un pequeño paréntesis para poder poner algo de contexto sobre la instrucción \texttt{git log} y la información que se necesita en este aquí.
Lo que se busca en este proyecto en concreto es saber todo el historial de cambios que ha sufrido una determinada línea dentro de un fichero.\\

Para llevar a cabo esto, en un principio se estudió la posibilidad de utilizar el comando \texttt{git blame}, el cual aporta información sobre la historia de una línea. \texttt{blame} se suele utilizar en \texttt{git} para depurar errores, sobre todo. Este comando nos permite filtrar por unas determinadas líneas dentro de un fichero, podemos ver el \emph{commit} que modificó por última vez cada una de las líneas.
Sin embargo, la información que proporciona \texttt{blame} se nos queda un poco escasa para el propósito de este proyecto, por lo que se decide seguir investigando sobre la funcionalidad que ofrecen las distintas instrucciones de git, y revisar las distintas librerías JavaScript que nos permitan implementar esto mediante código en nuestro servidor, hasta tener conocimientos suficientes para tomar la siguiente decisión: explotar la instrucción \texttt{git log}.\\

La ejecución de la instrucción \texttt{git log} sin ningún parámetro, devuelve por defecto una lista de todos los \texttt{commits} realizados en ese repositorio en orden cronológico inverso. Es decir, muestra primero los \texttt{commits} más recientes. En la figura~\ref{fig:log} podemos observar el formato en que \texttt{git log} nos da información.


\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.70]{img/salidaGitLog}
	\caption{Salida por defecto de la instrucción \texttt{git log}}
	\label{fig:log}
\end{figure}

\ \\  % asi se hacen 1 saltos de linea

La salida del comando es cada \emph{commit} con su suma de comprobación SHA-1, el nombre y correo del autor, la fecha y el mensaje que el autor ha escrito para ese \emph{commit}.\\

La instrucción \texttt{git log} posee múltiples opciones para ajustar la búsqueda que realmente se quiere, las opciones que se deciden utilizar en este proyecto son las siguientes:

\begin{verbatim}
git log -L numeroLinea,numeroLinea:nombreFichero
\end{verbatim}

Con la utilización de estas opciones se obtiene una lista de todos los cambios que ha sufrido la línea indicada en el parámetro desde su creación en el fichero hasta la actualidad.

Podemos ver en el siguiente ejemplo, la salida del comando que estamos tratando en nuestro código, se muestra en la figura~\ref{fig:log2}.

\begin{verbatim}
git log -L 155,155:git-web--browse.sh
\end{verbatim}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.8]{img/salidaGitLogOpciones}
	\caption{Salida de la instrucción \texttt{git log} con las siguientes opciones:\\ git log -L nºLínea,nºLínea:nombreFichero}
	\label{fig:log2}
\end{figure}

Analizando dicha salida, se observa que la línea 155 del fichero \texttt{git-web--browse.sh} ha sufrido los siguientes cambios.

\begin{enumerate}
	\item Cuando la línea se incluyó dentro del fichero por primera vez en un \texttt{commit} fue como:
	
\begin{verbatim}
	    firefox|iceweasel)
	\end{verbatim}

	\item El primer cambio que sufrió fue borrar las tabulaciones del principio:

	\begin{verbatim}
	firefox|iceweasel)
	\end{verbatim}
	
	\item Y por último se le añadió texto:
	
	\begin{verbatim}
	firefox|iceweasel|seamonkey|iceape)
	\end{verbatim}
\end{enumerate}

Para poder implementar esta idea en código dentro del proyecto,  hemos utilizado la librería de JavaScript \texttt{simple-git}\footnote{\url{https://www.npmjs.com/package/simple-git}}.\\ 

Una vez explicado esto, podemos cerrar el paréntesis y seguir con el análisis del proceso. A modo de recordatorio diremos que este punto se han almacenado las líneas del grupo ``Zona naranja'' con el siguiente formato:

\begin{verbatim}
var lineaSchema = mongoose.Schema({

linea: String,
fichero: String,
numLinea: String,
longitudLinea: String,
pasadoRojo: Boolean
historia: []

}); 
\end{verbatim}

Se ejecuta la instrucción \texttt{git log} con las opciones correspondientes explicadas anteriormente, para cada una de ellas.
La salida proporcionada por la instrucción se analiza para comprobar si la línea en cuestión posee algún momento de su historia con una longitud mayor a 80 caracteres.

Si esto ocurre se modifica su registro en la base de datos de tal manera que su parámetro ``pasadoRojo'' pasa a tener un valor igual a \texttt{True} y en su parámetro ``historia'' se guardan todos los estados que ha tenido dicha línea en su pasado y que cumplen dicha condición.

\section{Análisis del pasado de una línea} 
\label{sec:analisis-del-pasado-de-una-linea}

Realmente la cuestión buscada en este punto del proceso que explico en esta memoria, es la iteración en la que la línea ha pasado de estar en la zona roja (mayor de 80 caracteres) a estar en la zona naranja (entre 70 y 79 caracteres).\\

Hay que entender que muchas veces, se puede dar esta iteración y aun así no ser el caso que incumbe a este estudio, por tanto, se ha de analizar el pasado de la línea, y para implemetar esta idea en código, la única forma que tenemos es comprobar que en ese cambio, la línea actual y la línea en el pasado: son suficientemente parecidas como para que el cambio pueda deberse a nuestro motivo de estudio, es decir, que la Línea actual haya pasado de tener más de 80 caracteres, a tener entre 70 y 79, y que el cambio haya sido acortar el nombre de una variable. \\

Para intentar clarificar este último párrafo mostramos esta cuestión en un ejemplo. La clave que se intenta explicar es que la línea puede tener infinitos cambios en su pasado, de hecho puede ser que pase de la zona roja a la zona naranja, vuelva otra vez a la zona roja, pase a la verde, etc.
Lo que se intenta comprobar es que la línea actual es lo suficientemente parecida a la última versión de la línea en la que tenía más de 80 caracteres, para comprobar, como ya se explica en el párrafo anterior, si el cambio se produce por el motivo estudiado.
A continuación tenemos el siguiente ejemplo sacado de nuestro propio estudio:

\begin{verbatim}
settings = {'FEED_FORMAT': format, 'FEED_EXPORT_INDENT': None}
settings = {'FEED_FORMAT': format, 'FEED_EXPORT_INDENT_WIDTH': None}
\end{verbatim}

La primera línea de código, es la que hay en la actualidad en el repositorio, y la segunda es la última versión que tenía más de 80 caracteres en su pasado.
Es decir, esta línea entraría claramente en nuestro análisis, ya que podemos comprobar que la línea en la actualidad es prácticamente igual a la versión de la línea que tenía más de 80 caracteres, de hecho, podemos intuir que la línea no ha sufrido más cambios después, y que la iteración de zona roja a zona naranja es el último cambio sufrido por dicha línea.

Sin embargo, se puede dar el caso en que la línea ha sufrido ese cambio, pero más adelante sufre otros, de forma que la Línea actual queda bastante cambiada, pero sigue teniendo las características de estar en la zona naranja, la comparativa entre la última versión de la línea en la zona roja y la línea actual queda entonces así:

\begin{verbatim}
[settings, data] = {'FEED_FORMAT': None}
settings = {'FEED_FORMAT': format, 'FEED_EXPORT_INDENT_WIDTH': None}
\end{verbatim}

Esta línea no entra en los filtros del estudio, ya que como podemos ver la línea en la actualidad no es lo suficientemte parecida a su última versión en la zona roja. Esta línea ha pasado de estar en la zona roja a la zona naranja a lo largo de su historia, sin embargo, no entraría dentro de los parámetros de nuestro proceso.

Volviendo al análisis del proceso, en este punto todavía no se puede saber si la línea ha sufrido ese cambio por el motivo del estudio que explicamos en esta memoria.
Lo que se realiza aquí es un filtrado para comprobar que la línea actual es suficientemente parecida a su pasado como para que esta cuestión pueda llegar a darse. Para ello se utiliza la distancia de Levenshtein\footnote{\url{https://es.wikipedia.org/wiki/Distancia_de_Levenshtein}}.\\ 

Analizando la salida que nos proporciona la distancia de Levenshtein, se fija un umbral de decisión.

Se obtiene toda la historia de la línea en cuestión en la que su longitud fue mayor a 80 caracteres, accediendo para ello al parámetro en el que se ha guardado dicha información. En este punto se compara la línea actual con cada uno de los estados en su pasado.

En función de la respuesta que proporcione Levenshtein y en base al umbral de decisión que anteriormente se ha fijado se comprueba la siguiente cuestión:

Si la respuesta está dentro del umbral, se mantiene almacenado ``el estado de la línea en el pasado'' que se acaba de comprobar, en caso contrario, se desecha, actualizando el registro correspondiente en BBDD.\\

Cuando se termina esta comprobación para cada una de las líneas, cabe destacar el estado en el que se encuentra el proceso de análisis en este punto.

Se hace una limpieza en BBDD de los registros de líneas que no cumplen todos los parámetros de los filtros expuestos anteriormente. De esta manera, se mantienen únicamente las líneas que todavía se consideran conflictivas.
En el parámetro ``historia:[]'' de cada una de ellas se mantienen guardados todos los estados del pasado de dicha línea, los cuales son mayores a 80 caracteres y se parecen lo suficiente a la línea actual como para poder darse el caso que se maneja en este estudio. %(A modo de explicación diré aquí que del parámetro ``historia:[]'' sólo interesa la última iteración en que la línea ha estado en la zona roja antes de pasar a la naranja, y esto es lo que debería estar guardado. Si en algún caso este array contiene más de un elemento, y por tanto, además de esto último, hemos mantenido algún otro estado del pasado de la línea anterior, porque cumpla con los parámetros de los filtros, no importará, ya que más adelante, se ``limpiará'' esta ``basura''.)%

\ \\ \ \\ \ \\ \ \\ 

\section{Clasificación de líneas conflictivas} 
\label{sec:clasificacion-de-lineas-conflictivas}

En este punto, se dispone en la BBDD únicamente de las líneas que se han considerado conflictivas, y que por tanto, han superado todos los filtros del proceso de estudio. En este punto del análisis se realiza una clasificación basada en el motivo por el cual la línea ha acortado su longitud.\\

Dentro de los posibles casos, hemos decidido clasificar las líneas en 4 grupos --recordemos que siempre comparando la iteración en la que la línea pasa de tener más de 80 caracteres a tener entre 70 y 79--: 

\begin{enumerate}
	\item La línea se diferencia por el único motivo del cambio de longitud de una sola palabra (caso a estudiar).
	
	\item La línea se diferencia por el único motivo de la eliminación de 4 espacios iniciales (tabulaciones).
	
	\item La línea se diferencia por la eliminación de 4 espacios iniciales (tabulaciones), y además por el cambio de longitud de una sola palabra. (posible caso a estudiar).
	
	\item Resto de líneas.
	
\end{enumerate}

Para plasmar esta clasificación en el código de nuestro proyecto se han elaborado 3 procesos distintos. Cada par de líneas a estudiar (línea antigua con más de 80 y línea actual entre 70 y 79) será analizado por cada uno de los procesos. Según los resultados obtenidos se decide si la línea encaja en algunos de los 3 grupos de los que se dispone, o en caso contrario, será descartada en el último grupo \textbf{Resto de líneas}.

\begin{itemize}
	\item \textbf{La línea se diferencia por el único motivo del cambio de longitud de una sola palabra: } Se realiza una partición, tanto de la línea antigua como de la línea actual, por espacios. De manera que dispondremos de dos arryas en los cuales tendremos guardadas cada una de las distintas palabras de cada una de las líneas.
	A continuación se cruzan ambos arrays realizando una comparación de cada una de sus posiciones, con esta comparación se busca encontrar el caso en el que todas las posiciones de ambos arrays sean idénticas excepto una. Si esto ocurre nos encontramos ante un caso en el que las dos líneas son idénticas exceptuando una palabra. Esta palabra puede ser una posible variable, por tanto, si esto ocurre se decide añadir el par de líneas a este grupo.
\end{itemize}

\begin{itemize}
	\item \textbf{La línea se diferencia por el único motivo de la eliminación de los 4 caracteres iniciales: }En primer lugar se eliminan los 4 primeros espacios de la línea antigua, y se guarda en una línea auxiliar el resto de la línea. Una vez hecho esto, se realiza la siguientes comprobaciones: 
	1 - se compara la línea actual con la línea auxiliar y se comprueba si son exactamente iguales. 2 - se comprueba que los 4 primeros caracteres que anteriormente hemos eliminado de la línea antigua, son efectivamente, 4 espacios en blanco (tabulaciones).
	Si ambas comprobaciones se cumplen, el par de líneas será introducido en este grupo.
\end{itemize}

\begin{itemize}
	\item \textbf{La línea se diferencia por la eliminación de 4 espacios iniciales (tabulaciones), y además por el cambio de longitud de una sola palabra: }Al igual que en el primer grupo, se realiza una partición, tanto de la línea antigua como de la línea actual, por espacios. De manera que dispondremos de dos arryas en los cuales tendremos guardadas cada una de las distintas palabras de cada una de las líneas. Una vez disponemos de estos dos arrays, se realizan 3 comprobaciones.
	1 - se comprueba mediante ambos arrays que las dos líneas contienen el mismo número de palabras. 2 - si se cumple la comprobación uno, se comparan las dos líneas originales, para comprobar que en un principio no son iguales, de esta manera se llega a la conclusión de que lo único que diferencia a ambas líneas son espacios en blanco. 3 - si se cumplen las comprobaciones uno y dos, pasaremos a comprobar mediante los dos arrays obtenidos que las palabras de ambas líneas coinciden exactamente exceptuando una sola palabra.
	Si las tres comprobaciones se cumplen, dicho par de líneas será introducido en este grupo.
\end{itemize}

Una vez realizada esta clasificación de todas las líneas conflictivas, nos encontramos en disposición de mostrar, explotar y analizar los resultados de nuestro estudio.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}
\label{chap:resultados}
\section{Resultados del análisis general}
\label{sec:resultados-analisis- general}

Una vez que hemos creado el software, podemos analizar un gran volumen de líneas de código en lenguaje Python.

%No presentamos una aplicación que ayuda al desarrollador al mismo tiempo que está programando, o que le permite revisarlo una vez terminado, como podrían ser otros proyectos sobre el análisis de la calidad del código como pueden ser \texttt{pycodestyle}, \texttt{pyflakes} o \texttt{pylint}.
%Más bien, lo que ofrecemos es un análisis de un amplio volumen de código, un estudio, para intentar llegar a una conclusión sobre un problema planteado.

\ \\ % asi se hacen 1 saltos de linea.
Cabe destacar que para la realización de este proyecto hemos intentado recoger datos del ``mundo real'', es decir, de proyectos reales de software libre, que nos permitan sacar conclusiones reales. Por ello, se analizan repositorios de GitHub, en particular, los repositorios más famosos y de mayor tamaño de Python en dicho portal para formar la muestra de nuestro estudio.

Para dar a dicha muestra las características oportunas para este proyecto, se ha pensado en la variedad. Esto quiere decir que para obtener datos de un mayor número de desarrolladores, se ha decidido seleccionar el mayor número de repositorios posibles, en lugar de escoger un único repositorio de gran tamaño. Se ha tomado esta decisión pensando que en un mismo proyecto se suele trabajar bajo las mismas pautas y reglas de calidad marcadas de antemano. Por tanto, aunque dicho proyecto cuente con varios desarrolladores, todos ellos generarán código bajo las mismas normas y nuestro estudio quedaría reducido a ese único proyecto.

%La conclusión que nosotros queremos sacar en este proyecto sobre el problema explicado es a nivel global, y aunque el volumen analizado no sea todo lo extenso que se quiere, ya que sabemos que a este nivel no podemos analizar todo GitHub por así decirlo, sí que hemos querido qué los datos tengan la variedad para que así sea.

\ \\ \ \\% asi se hacen 1 saltos de linea.
Así, hemos analizado en total el siguiente número de líneas, tal y como se muestra en la figura~\ref{fig:resultados_generales}:

\begin{itemize}
	\item \textbf{Número total de líneas analizadas: }369.911
\end{itemize}

De estas líneas, y con la nomenclatura explicada en el capítulo 4, hemos encontrado:

\begin{itemize}
	\item \textbf{Número de líneas verdes: }330.900
\end{itemize}

\begin{itemize}
	\item \textbf{Número de líneas naranjas: }20.107
\end{itemize}

\begin{itemize}
	\item \textbf{Número de líneas rojas: }18.904
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{img/diagramaBarras}
	\caption{Diagrama de barras de los resultados generales.}
	\label{fig:resultados_generales}
\end{figure}

El primer punto a destacar de estos resultados son los datos obtenidos para cada grupo de líneas, se ha analizado código subido a repositorios importantes de Github  sobre Python. Esto hace pensar que dicho código sigue la guía de estilo PEP8, de manera que no se encontrarán apenas ``líneas rojas''. Sin embargo, se puede observar que el número de este grupo de líneas es similar al del grupo ``líneas naranjas''.

Para esclarecer este dato se ha realizado un análisis más en profundidad sobre el mismo. Se puede observar que el número de líneas (18.904) puede parecer grande en un principio, sin embargo, cabe destacar que esto tan sólo supone el 5,11\% del total analizado, un porcentaje bastante bajo.
Para indagar más sobre este dato se decide en este punto añadir una comprobación en el código del proyecto. Esta nueva comprobación consiste en averiguar cuentas de esas líneas son comentarios (tanto comentarios \emph{in-line}, como comentarios de varias líneas). De esta manera se sabrá si este dato está falseado y nos encontramos ante líneas que no son líneas \emph{reales} de código fuente.

En dicho análisis obtenemos un resultado de 1.000 líneas, es decir, un 5,28\%. Lo que quiere decir que sí hemos encontrado líneas de código fuente que están en nuestra \emph{zona roja}.

Poniendo el foco en los grupos de líneas menores a 80 caracteres, se puede comprobar
que la inmensa mayoría están en las llamadas ``línea verdes'' un 89,45\%.
Esto quiere decir que el grupo conflictivo que nos incumbe en este proyecto, las ``línea naranjas'', queda en un 5,43\%.

%La gran mayoría de las líneas están por debajo del umbral que marca la guía de estilo PEP8, incluso, por debajo 70 caracteres, es decir, 10 menos del límite. Por otro lado, tenemos un pequeño porcentaje de líneas que han pasado de los 80 caracteres y que no están cumpliendo la guía de estilo PEP8. Por último, tenemos otro pequeño porcentaje de líneas que están en nuestro rango \emph{conflictivo}, y las cuáles debemos analizar en más profundidad para poder llegar a una conclusión.
Una vez procesados los datos totales del estudio, centraremos nuestro interés en los distintos repositorios que hemos utilizado.
Tenemos el siguiente listado:

\begin{table}[H]
\centering
\caption{Proyectos analizados y resultados obtenidos.}
\label{tab:proyectos}
\begin{tabular}{|l|r|r|r|r|r|}
 \hline
Proyecto & Verdes & Naranjas & Rojas & Rojas Comentarios  & Totales  \\ \hline \hline
youtube-dl & 112.898 & 6.332 & 8.507 & 5 (0,06\%) &  127.737 \\ \hline
 SerpentAI & 3.396 & 130 & 282 & 0 (0,00\%) & 3.808\\ \hline
 requests & 29.164 & 1.475 & 3.235 & 79 (2,44\%) & 33.874\\ \hline 
 scrapy & 31.174 & 2.400 & 1.709 & 99 (5,79\%) & 35.283\\ \hline 
 pythondotorg & 10.609 & 380 & 601 & 3 (0,49\%) & 11.590\\ \hline 
 models & 56.246 & 2.949 & 1.058 & 683 (0,64\%) & 60.253\\ \hline 
 lbry & 24.832 & 1.700 & 1.885 & 59 (3,12\%) & 28.417\\ \hline 
 keras & 49.456 & 3.428 & 1.525 & 60 (3,93\%)& 54.409\\ \hline 
 flask & 13.030 & 1.307 & 99  & 11 (11,11\%) & 14.436\\ \hline 
 awesome-python & 70 & 3 & 3 & 1 (33,30\%) & 76\\ \hline 
 awesome-machine-learning & 25 & 3 & 0 & 0 (0,00\%) & 28\\ \hline 
 
 
\end{tabular}
\end{table}

Se puede observar que hemos tomado como muestra repositorios de muy diversas características. Cabe destacar:

\begin{itemize}

  \item Como es de esperar, en todos los repositorios, la gran mayoría de líneas son verdes.

  \item Sólo hemos encontrado un repositorio que no tenga líneas rojas, aunque solo tiene 38 líneas en total.

  \item Hay 5 repositorios en los que hay más líneas naranjas que rojas, 5 repositorios en los que hay más líneas rojas que naranjas, y un repositorio en el que hay las mismas líneas rojas que naranjas.

\end{itemize}

\section{Resultados del análisis del grupo conflictivo}
\label{sec:resultados-analisis-grupo-conflictivo}

En esta sección analizamos con detalle el grupo que hemos considerado \emph{conflictivo}.
Después de pasar nuestro primer filtro (véase la sección~\ref{sec:analizar-el-grupo-de-lineas-seleccionadas-para-nuestro-estudio}), las primeras líneas que podemos considerar \emph{conflictivas} según nuestros parámetros, son las siguientes:

\begin{itemize}
	\item \textbf{Número de líneas conflictivas: }396
\end{itemize}

Esto nos da:

\begin{itemize}
	\item 0.10\% del total de líneas analizadas (369.911)
	\item 1.96\% del total de líneas en zona naranja (20.107)
\end{itemize}

Se puede observar que los porcentajes que se manejan en este punto son bajísimos. Realizando sobre estas 396 líneas la clasificación que se detallada en el capítulo 4 (véase la sección~\ref{sec:clasificacion-de-lineas-conflictivas}) se obtienen como resultado\footnote{En los ejemplos que se muestran \emph{verbatim} en esta memoria, se ha omitido la indentación de las líneas para que quepan en el ancho de página.}:

\begin{itemize}
	\item \textbf{La línea se diferencia por el único motivo de la eliminación de 4 espacios iniciales (tabulaciones): }1
	
	Ejemplo: \\
	Línea actual:
    \begin{footnotesize}
	\begin{verbatim}  
	 'url': 'http://91porn.com/view_video.php?viewkey=7e42283b4f5ab36da134',
	\end{verbatim}
	\end{footnotesize}

	Línea en el pasado:
	\begin{footnotesize}
	\begin{verbatim}  
     'url':'http://91porn.com/view_video.php?viewkey=7e42283b4f5ab36da134',
	\end{verbatim}
	\end{footnotesize}
	
	
	\item \textbf{La línea se diferencia por el único motivo del cambio de longitud de una sola palabra: }125
	
	Ejemplo: \\
	Línea actual:
    \begin{footnotesize}
	\begin{verbatim} 
	'subtitles':self.extract_subtitles(video_id, subtitles_id, hl),
	\end{verbatim}
	\end{footnotesize}
	
	Línea en el pasado:
	\begin{footnotesize}
	\begin{verbatim} 
	'subtitles':self.extract_subtitles(video_id, video_subtitles_id, hl),
	\end{verbatim}
	\end{footnotesize}
	
	
	\item \textbf{La línea se diferencia por la eliminación de 4 espacios iniciales (tabulaciones), y además por el cambio de longitud de una sola palabra: }3
	
	Ejemplo: \\
	Línea actual:
	\begin{footnotesize}
	\begin{verbatim} 
	'https://tv.nrk.no/program/Episodes/{series}/{season}'.format(
	\end{verbatim}
	\end{footnotesize}
	
	Línea en el pasado:
	\begin{footnotesize}
	\begin{verbatim} 
	self.url_result('https://tv.nrk.no/program/Episodes/{series}/{season}'.format(
	\end{verbatim}
	\end{footnotesize}
	
	
	\item \textbf{Resto de líneas: }267
	
	Ejemplo: \\
	Línea actual:
	\begin{footnotesize}
	\begin{verbatim} 
	'url':'http://www.chilloutzone.net/video/eine-sekunde-bevor.html',
	\end{verbatim}
	\end{footnotesize}
	
	Línea en el pasado:
	\begin{footnotesize}
	\begin{verbatim} 
	u'url':u'http://www.chilloutzone.net/video/enemene-meck-alle-katzen-weg.html',
	\end{verbatim}
	\end{footnotesize}
	
	
	
\end{itemize}

En esta clasificación disponemos de dos grupos que entran dentro del interés de nuestro estudio, los cuales son: ``La línea se diferencia por la eliminación de 4 espacios iniciales (tabulaciones), y además por el cambio de longitud de una sola palabra'' y ``La línea se diferencia por el único motivo del cambio de longitud de una sola palabra''. Unificando estos dos grupos y estableciendo los porcentajes en función de las 396 líneas conflictivas, se obtiene que:


\begin{itemize}
	\item \textbf{Grupo conflictivo: }32,32\%
	\item \textbf{Grupo NO conflictivo: }67,68\%
\end{itemize}

Como podemos observar en todos los datos mostrados hasta ahora, el porcentaje de líneas que entran en nuestro estudio es mucho menor que el porcentaje que se descarta.

Comparando este último filtrado con los datos iniciales, tenemos que \textbf{128 líneas de 369.911} pueden haber sufrido el cambio que incumbe a este proyecto. Esto supone un \textbf{0.034\%}. Este dato es un porcentaje ínfimo, que da a entender que el debate sobre esta cuestión carece de sentido, o al menos, no debería tener la importancia que se le ha dado.

\subsection{Análisis (manual) de líneas particulares}


Por último, cabe destacar que hemos obtenido un resultado total de 128 líneas, sin embargo, no podemos afirmar que dichas líneas hayan sufrido el cambio explicado en esta memoria a propósito, esa afirmación es totalmente subjetiva.
En este punto, queda pendiente el ejercicio de que un humano revise esas líneas y decida si la línea ha pasado de tener una longitud mayor a 80 caracteres a tener una longitud menor a 80 caracteres, reduciendo para ello la longitud de una sola variable, y por tanto, el motivo para ello ha sido el problema explicado en este proyecto.

Para ilustrar esta cuestión, se recoge una pequeña muestra de nuestros resultados, y se procede a anlizarlos manualmente:

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim} 
_VALID_URL = r'https?://(?:www\.)?alpha\.com/videos/(?P<id>[^/]+)'
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
_VALID_URL = r'https?://(?:www\.)?alpha\.com/videos/(?P<display_id>[^/]+)'
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

En primer lugar intento detectar la parte que se ha modificado y analizar el porqué.
En este caso la parte modificada no parece ser una variable, las razones que me llevan a llegar a esta conclusión son las siguientes.
El nombre de la variable inicial (``\_VALID\_URL'') y su contenido me hace pensar claramente que estamos ante una url que se está almacenando en una variable.
No dispongo de más contexto del resto del código que tiene esta línea (las líneas colindantes), pero basándome en mi experiencia, aunque a veces las url con las que trabajamos se conformen dinámicamente dentro del código, no me parece que la parte modificada (``display\_id'' a ``id'') sea una variable en sí. 
Por tanto, creo que en este caso no se trata de un cambio en el nombre de la variable con el fin de cumplir con la guía de estilo PEP8.
\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
return self.playlist_result(entries, video_id, title, description)
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
return self.playlist_result(entries, video_id, playlist_title, description)
\end{verbatim}
\end{footnotesize}


\textbf{Análisis}:

En esta línea observo que la parte que se ha modificado es un parámetro que se le está pasando a una función. Esto me hace pensar que muy probablemente me encuentro ante una variable.
Observando la modificación en sí (``playlist\_title'' a simplemente ``title''), puedo afirmar que el nombre de la variable ha perdido sentido. No parece que el hecho de denominar a una variable con el único nombre de \emph{título} tenga demasiado sentido.
En esta línea, por tanto, me atrevo a decir que sí se trata de un cambio para cumplir con la guía de estilo PEP8, y además, el código ha quedado peor que el original. Esto quiere decir que esta línea sufre el problema explicado en esta memoria.
\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
'skip': 'redirect to http://swrmediathek.de/index.htm?hinweis=swrlink',
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
'_skip': 'redirect to http://swrmediathek.de/index.htm?hinweis=swrlink',
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Observo en esta línea que me encuentro ante una asignación de su valor a una variable inicial, dicha variable inicial es la palabra modificada.
Esto quiere decir que cumple la primera condición, sin embargo, observo la modificación (``\_skip'' a ``skip'') y no parece que el nombre de la variable haya perdido ningún sentido. 
Puedo afirmar por tanto, que en este caso no estamos ante una línea que ha sufrido la modificación estudiada en este proyecto.
\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
except (TimeoutError, HTTPException, SocketError, ProtocolError) as e:
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
except (TimeoutError, HTTPException, SocketError, ConnectionError) as e:
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Observo en esta línea que la palabra modificada es un parámetro que esta recibiendo una función, y por tanto, es muy probable que nos encontremos de nuevo ante una variable.
De nuevo me voy a analizar la modificación sufrida por esta: ``ConnectionError'' a ``ProtocolError''). A simple vista puedo ver que la variable ha cambiado su nombre porque ha cambiado su sentido, y el motivo en este caso no ha sido intentar cumplir con la guía de estilo PEP8.
Tampoco esta línea ha sufrido el cambio que se explica en esta memoria.
\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
elif status['startup_status']['code'] == LOADING_WALLET_CODE:
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
elif status['result']['startup_status']['code'] == LOADING_WALLET_CODE:
\end{verbatim}
\end{footnotesize}


\textbf{Análisis}:

En esta línea observo algo que también puede ocurrir en el proceso de análisis. Debido a la forma en la que se clasifican las líneas debido a su modificación (véase la sección~\ref{sec:clasificacion-de-lineas-conflictivas}), la parte de línea que detecta que ha cambiado es ``status['result']['startup\_status']['code']'' por ``status['startup\_status']['code']''. Se observa que al no tener espacios, la herramienta lo ha detectado como una palabra y posible variable. 
De esta forma podemos afirmar de nuevo que no estamos ante una línea que haya sufrido el cambio que nos incumbe en este proyecto.

\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
`(batch, new_rows, new_cols, filters)` if data_format='channels_last'.
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
`(batch, new_rows, new_cols, nb_filter)` if data_format='channels_last'.
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Observo en esta línea que de nuevo me puedo encontrar ante una variable, debido al formato de dicha línea.
Sin embargo, analizando el cambio en sí (``nb\_filter'' a ``filters''), no veo que el nombre de la variable haya perdido sentido. Por tanto, no puedo afirmar que este cambio no se haya producido para cumplir la guía de estilo PEP8, sin embargo, sí puedo afirmar que no estoy ante una línea que ha sufrido el cambio del que se habla en esta memoria, ya que el código resultante no me parece peor que el original.

\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
def _download_name(self, name, timeout=None, download_directory=None,
\end{verbatim}
\end{footnotesize}

Línea en el pasado:\footnote{La línea original está en una única línea. Se muestra así para que quepa en el ancho de página de esta memoria.}:
\begin{footnotesize}
\begin{verbatim}
def _download_name(self, name, timeout=conf.settings.download_timeout,
                                                     download_directory=None,
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Observando la parte modificada, puedo ver que no me encuentro ante el nombre de una variable. El cambio es pasar de ``timeout=conf.settings.download\_timeout'' a ser ``timeout=None''.
La herramienta ha detectado la variable y su asignación como una sola palabra al carecer de espacios.
Observando el cambio no me parece en absoluto que este se haya dado para cumplir la guía de estilo PEP8.
\ \\ \ \\ \ \\% asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
'lynda returned error: %s' % video['Message'], expected=True)
\end{verbatim}
\end{footnotesize}

Línea en el pasado:
\begin{footnotesize}
\begin{verbatim}
'lynda returned error: %s' % video_json['Message'], expected=True)
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Observo esta línea y llego a la conclusión de que la parte afectada no es una variable, sin embargo, puede ser una función o método.
El cambio es ``video\_json['Message']'' a ``video['Message']''.
Creo que este cambio ha hecho que el nombre del método en cuestión pierda sentido, ya que se le ha quitado información sobre el formato al nombre, y por tanto el código resultante me parece peor que el original.
Creo que esta línea si que puede entrar dentro del grupo que está afectado por el cambio que se explica en este proyecto.

\ \\ % asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
with mock.patch.object(attr, '__setattr__') as mock_setattr, \
\end{verbatim}
\end{footnotesize}

Línea en el pasado:	
\begin{footnotesize}
\begin{verbatim}
with mock.patch.object(SettingsAttribute, '__setattr__') as mock_setattr, \
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Veo en esta línea que la palabra afectada es un parámetro que se le pasa a una función, por tanto, al igual que en ocasiones anteriores puedo afirmar que estamos ante una variable.
Observando el cambio (``SettingsAttribute'' a ``attr''), parece bastante claro que el nombre de la variable ha perdido todo el sentido que poseía. En este caso, de nuevo el código resultante ha quedado peor que el código original. De manera que esta línea también ha sufrido el cambio estudiado en esta memoria.
\ \\ \ \\ \ \\ \ \\% asi se hacen 1 saltos de linea

\textbf{Par de líneas}:

Línea actual:
\begin{footnotesize}
\begin{verbatim}
log.info("Responding with %s infos", str(len(blob_infos)))
\end{verbatim}
\end{footnotesize}

Línea en el pasado:	
\begin{footnotesize}
\begin{verbatim}
logging.info("Responding with %s infos", str(len(blob_infos)))
\end{verbatim}
\end{footnotesize}

\textbf{Análisis}:

Observo en esta línea que la parte modificada (``logging.info'' a ``log.info'') no es una variable. Además puedo afirmar viendo el cambio, que no se ha producido por el motivo de cumplir la guía de estilo PEP8.
Por tanto, se puede decir que esta línea no ha sufrido el cambio mencionado en esta memoria.
\ \\ % asi se hacen 1 saltos de linea

\textbf{Conclusión del análisis manual}: Hemos seleccionado una pequeña muestra de 10 líneas obtenida de nuestros resultados. Hemos obtenido 3 SÍ y 7 NO. Estos resultados son subjetivos y sólo aportan evidencia parcial y no completa. Además nos falta mucho contexto sobre el código analizado, ya que estamos tratando sobre líneas totalmente aisladas. Aun así, permiten analizar en detalle el fondo de la cuestión y ampliar la perspectiva del análisis, tanto para ver la problemática a la que nos enfrentamos como los resultados de la misma. De nuevo, hemos obtenido generalmente unos resultados negativos respecto al caso buscado.


\ \\ \ \\% asi se hacen 1 saltos de linea
%Lo que sí podemos afirmar es que con los resultados obtenidos en este proyecto somos capaces de llegar a una conclusión.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

En el Capítulo 2 (en las Secciones~\ref{sec:objetivo-principal} y \ref{sec:objetivos-secundarios}) de esta memoria se exponen una serie de objetivos, tanto principales como secundarios, que, después de desarrollar los Capítulos~\ref{chap:estado-del-arte}, \ref{sec:diseno} y \ref{chap:resultados}, podemos evaluar si se han cumplido o no.

En primer lugar, se planteaba como gran objetivo principal ser capaces de realizar un amplio estudio sobre código Python para poder llegar a una conclusión sobre si los desarrolladores estaban realizando en líneas generales una determinada práctica.

Para ello necesitábamos que nuestro estudio fuese lo suficientemente amplio como para que los parámetros utilizados fueran reales para poder dar una conclusión a nivel global, también necesitábamos que nuestro código tuviese los filtros suficientes, y la capacidad de acotar lo suficiente nuestro problema como para dar justo el resultado que necesitamos.

Creo que este objetivo se ha cumplido completamente, ya que si bien es cierto que el estudio podría ser más amplio, o que en los resultados se podría haber acotado incluso más, los datos obtenidos después de analizar los puntos 4 y 5 de la memoria son suficientes como para llegar a una conclusión sobre el estudio propuesto. Dicha conclusión es que los desarrolladores de código Python no están realizando la práctica que aquí se debate, ya que los resultados son claramente negativos.

\ \\ \ \\ \ \\ \ \\% asi se hacen 1 saltos de linea
En este punto también se plantea otro objetivo, quizás más secundario, pero sobre todo más abstracto. Planteamos la idea, sobre todo a nivel de estudiante, de plantearse que es realmente un código de calidad, y la correcta utilización de algunas reglas o guías de estilos como PEP8 o similares.

No se sí se puede decir que esto sea un objetivo en sí, y si lo es, que se haya cumplido como tal. Creo que este proyecto en sí no se ha centrado en expandir esta idea, quizás si algún alumno lee esta memoria sí que pueda obtenerla. Sin embargo puedo decir que este objetivo se ha cumplido con creces en mi persona. Antes de realizar este proyecto no me había planteado tanto la diferencia entre un código que funciona y un código que es bueno.

En cuanto a los objetivos secundarios que comentamos también en el Capítulo 2 (en la Sección~\ref{sec:objetivos-secundarios}):

\begin{itemize}
	\item \textbf{Trabajar de una forma orientada al mundo profesional: } Este objetivo se ha cumplido con el uso de GitHub, centrándonos para el desarrollo de código en GitFlow. También lo he notado en que es un trabajo en el que estás mucho más solo que en el resto de tu vida universitaria, esto te permite enfrentarte sólo a los problemas, organizarte y dividir tu proyecto de la forma que creas necesaria.

\item \textbf{Aplicar tecnologías e ideas no vistas durante la vida universitaria: } Creo que este objetivo también se ha cumplido. En este proyecto he buscado en todo momento utilizar tecnologías que no he visto en mi vida universitaria o aplicarlas de distinta forma. Por eso en el caso de hacer un desarrollo en la parte del servidor en una posible futura aplicación cliente-servidor he utilizado Node.js y JavaScript como lenguaje. En la universidad hemos visto JavaScript, pero únicamente en la parte del cliente, que es lo más común. En la universidad sólo habíamos trabajado en servidor con java y Python con Django.
Para el tema de las bases de datos solo hemos visto SQL, trabajando sólo con bases de datos relaciones, por ese motivo decidí utilizar Mongo, para trabajar con una base de datos no relacional y poder captar las diferencias entre una y otra a la hora de utilizar realmente las dos.

Otra cosa que me gustaría destacar aquí es la elección de la estructura final del proyecto, ojeando proyectos anteriores como hacemos todos antes de realizar el nuestro he visto que casi todos se plantean como una aplicación cliente-servidor con Python en el servidor, JavaScript en el \emph{front-end}, y SQL como base de datos. He querido enfocar este proyecto como algo un poco distinto, y en mi caso, aunque es cierto que he querido crear una estructura cliente-servidor, para aprender más sobre el tema y utilizar \emph{frameworks} nuevos como Express, el desarrollo se ha centrado más en un estudio en el que queremos obtener unos resultados. El proyecto no ha tenido parte \emph{front-end} como tal.
\end{itemize}


\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Durante la realización de mi grado en la universidad Rey Juan Carlos me he formado en diferentes áreas y campos, muchos de ellos me han facilitado la realización de este proyecto. Algunas de ellas han sido:



\begin{enumerate}
  \item La programación: La base de este proyecto es la programación, y antes de entrar en la universidad, prácticamente yo no sabía lo que era eso (cabe destacar que ahora que he terminado, me dedico y quiero dedicarme toda la vida a ello). Algunas asignaturas como Fundamentos de la programación, Programación de Sistemas de Telecomunicación o Sistemas Operativos me han enseñado lo que es la programación a bajo nivel.
  \item Una vez que sabemos (o algo parecido) lo que es el paradigma de la programación a bajo nivel, hablando a más alto nivel, he aprendido todo lo relacionado con la programación en la parte del servidor en asignaturas como Servicios y Aplicaciones Telemáticas o Ingeniería de Sistemas de Telecomunicaciones.
  \item El aprendizaje de \texttt{GitHub} ha sido para mi muy importante para este proyecto. Es otra de las cosas que puedo decir que no sabía antes de empezar la carrera, ni \texttt{GitHub} ni cualquier control de versiones, esto es algo que me enseñó la asignatura Ingeniería de Sistemas de la Información. Además, puedo decir que sé a ciencia cierta que será algo que utilice constantemente en mi vida laboral.
  \item Por último, y para nada menos importante, está el concepto general de ser capaz de afrontar cualquier problema sin miedo y ser capaz de resolverlo, en este caso concreto el enfrentarme a nuevas tecnologías que nunca he utilizado y no tener miedo a utilizarlas.
  Esto es algo que no se aprende en ninguna asignatura en concreto pero que sin duda es algo con lo que salimos de nuestra vida estudiantil. 
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Como ya he comentado en alguna parte de la memoria, uno de mis objetivos era buscar tecnologías y formas de trabajar que no hubiera visto en la universidad, esto al principio fue bastante costoso, sin embargo creo que en el futuro puede tener bastantes beneficios, algunas de las cosas para las que esto me ha servido han sido:

\begin{enumerate}
  \item Montar un servidor con NodeJS implementado en JavaScript utilizando un framework desconocido para mi como Express.
  \item Utilización de una base de datos desconocida para mi como es MongoDB, y su conexión con el servidor.
  \item Enfocar un proyecto de grandes dimensiones desde el principio, y planificarlo de forma correcta uno mismo, tanto temporal como estructuralmente.
  \item El uso de \LaTeX. Una tecnología con la que he escrito esta memoria, y que aunque al principio parece muy farragosa, enseguida ves la facilidad que te aporta para redactar documentos de este tipo.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}
Todo software implementado tiene margen de mejora, en este proyecto tenemos varios puntos que merece la pena destacar.

\begin{enumerate}
	\item En primer lugar, y como ya hemos comentado también en algún punto, una mejora muy clara es montar la parte \emph{front-end} y hacer de este estudio una aplicación en la que quizás se puedan mostrar los resultados de forma más atractiva al usuario, y quizás añadir alguna funcionalidad o añadir algún otro estudio para dar más contenido a la aplicación.
	\item Mejorar la rapidez de la aplicación para poder analizar un mayor volumen de código. La base del análisis esta programada con varios hilos en paralelo para cada repositorio, esto hace que si el repositorio es demasiado grande y la capacidad del ordenador no es demasiado buena, se creen demasiados hilos y pueda dar problemas de rendimiento.
	\item Mejorar el filtrado para quedarnos con las líneas determinadas. En este proyecto creo que hemos conseguido afinar bastante, pero aun así, siempre se cuela la llamada basura, y en los resultados finales hemos tenido que dejar un apartado de ``Resto de líneas''.
	\item Mejorar el análisis de este mismo problema pensando otras opciones. Por ejemplo, hemos tenido en cuenta que el desarrollador cambia para ello una sola variable, o una sola variable y tabulaciones, pero ¿y si acorta dos variables en una misma línea? Ese caso no lo tenemos contemplado.
\end{enumerate}



\section{Valoración personal}
\label{sec:valoracion}

Creo que en este punto es hora de echar la vista atrás y reflexionar. Echar la vista atrás al principio de este proyecto y ver como ha quedado finalmente, de lo cual estoy, sinceramente orgulloso. Los resultados obtenidos como proyecto en sí me parecen más bien normales, de lo que sí me siento orgulloso es de como lo he tenido que compaginar con un trabajo a jornada completa desde su inicio, y aunque he tenido que hacer parones no deseados en su elaboración y no he tardado lo que me gustaría, lo he conseguido. También me gusta que es un proyecto algo distinto, en mi opinión, a muchos de los últimos que he visto.
Creo que también es hora de echar la vista más atrás y reflexionar sobre la vida universitaria, con este proyecto termino una etapa de mi vida, una etapa muy importante en la que he adquirido conocimientos, habilidades, he perdido miedos, me he hecho una persona adulta y todo ello me servirá para el resto de mi vida, tanto profesional como personal.
Cierro esta etapa con mucha alegría y muy orgulloso, y empiezo una nueva con mucha ilusión.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Instalaciones necesarias}
\label{app:instalaciones-necesarias}

Todo lo instalado se ha hecho sobre Windows 10.

\section{NodeJS} 
\label{sec:nodejs}

Lo primero que necesitamos instalar en este caso es Node en nuestro ordenador. Al igual que muchas aplicaciones, Node tiene su propio MSI(Microsoft Installer), el cual podemos descargar desde la página principal de Node e instalar fácilmente en nuestro ordenador siguiendo todos los pasos.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{img/installerNode}
	\caption{Descarga de NodeJS}
	\label{Figura 4.1}
\end{figure}


\section{NPM} 
\label{sec:npm}

Node Package Manager es un gestor de paquetes que nos ayuda a gestionar las dependencias de nuestro proyecto.\\
Entre otras cosas nos permite instalar librerías o programas de terceros, eliminarlas o mantenerlas actualizadas.\\
Generalmente se instala conjuntamente con Node.js de forma automática. \\

NPM se apoya en un fichero llamado \texttt{package.json} para guardar el estado de las librerías. 
Lanzamos el siguiente comando para realizar la creación del \texttt{package.json} e iniciar su configuración.

\begin{verbatim}
npm init 
\end{verbatim}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/npm-1}
	\caption{Formato del \texttt{package.json} después de lanzar el comando npm init}
	\label{Figura 4.2}
\end{figure}

Una vez tenemos el \texttt{package.json}, cada vez que queramos incluir una librería nueva a nuestro proyecto, debemos lanzar el siguiente comando:\\
Por ejemplo, en este caso, si queremos incluir la librería de Express, explicada en el apartado 3, lanzaríamos el siguiente comando.

\begin{verbatim}
npm install express --save 
\end{verbatim}

A medida que vayamos necesitando incluir más librerías a nuestro proyecto, iremos ejecutando este comando con cada una de ellas.\\

Cuando tengamos todas las librerías añadidas a nuestro proyecto, nuestro \texttt{package.json} tendrá un formato parecido a este:

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/package}
	\caption{Formato de nuestro \texttt{package.json}.}
	\label{Figura 4.3}
\end{figure}


\section{Creación de un nuevo proyecto Express} 
\label{sec:nuevo-proyecto}

Una vez tenemos el equipo listo, pasamos a crear un nuevo proyecto. En el punto 3, hemos explicado en que consiste Express (véase la sección~\ref{sec:express}), el framework de Node.js (véase la sección~\ref{sec:node-js}) con el que vamos a realizar nuestro proyecto.\\
Dentro de Express vamos a utilizar la librería de Express Generator~\cite{ExpressGenerator}, que nos crea una estructura base para una aplicación.\\
Para ello ejecutamos en el directorio en el que queramos crear nuestro proyecto los siguientes comandos:\\\\

Primero instalamos express-generator de forma global, añadiéndole el -g
\begin{verbatim}
npm install express-generator -g
\end{verbatim}

Seguidamente lanzamos:

\begin{verbatim}
express <nombreApp> [--ejs]
\end{verbatim}

\begin{verbatim}
cd <nombreApp>
\end{verbatim}

\begin{verbatim}
npm install
\end{verbatim}



Con esto se nos creará un proyecto con la siguiente forma:\\ 

\begin{figure}[H]
	\centering
	\includegraphics[scale=1.1]{img/estructura-proyecto}
	\caption{Estructura básica de un proyecto}
	\label{Figura 4.4}
\end{figure}

Dentro de la carpeta \emph{routes} meteremos el código JavaScript que ejecutaremos en la parte del servidor, y que tendrá toda la lógica de nuestro proceso.\\

Por último añadir que se puede encontrar el código de este proyecto en el siguiente repositorio público de GitHub:

\url{https://github.com/kivenoliva/LineLength}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\cleardoublepage
% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{unsrt}
\bibliography{memoria} 
\newpage \thispagestyle{empty} \cleardoublepage
\nocite{*}
% mArgumento para crear un "pull request"emoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
